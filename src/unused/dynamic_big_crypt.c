/*
 * The source for this file AUTO-GENERATED on:
 * Wed, Jul 08, 2015 11:16:05
 *
 * NOTE.  This file IS 100% auto-generated code.
 *
 * **DO NOT** edit any portion of this .c file. ANY change
 * made to this file WILL BE LOST, the next time the
 * 'make distclean' is run, or whenever the 'base' files
 * which generate this file are modified.
 *
 * If bugs are found, then they must be fixed in the file(s)
 * of dynamic_big_crypt_header.cin, which is the 'common'
 * functions, data and includes used by all hashes, OR
 * the bug must be fixed (carefully) in the file
 * dynamic_big_crypt_hash.cin   This second file is
 * a 100% common file.  Each of the hashes we have, MUST
 * be able to be run from this file, after it is run
 * through the dynamic_big_crypt_chopper.pl filter program
 * which was built specifically for this task. The
 * existing command line arguments which run
 * dynamic_big_crypt_chopper.pl are in the shell script
 * dynamic_big_crypt_generator.sh which is the script
 * what actually generated THIS file.
 */
 
/*****************************************************************************
 * This software was written by Jim Fougeron jfoug AT cox dot net
 * in 2013-2115. No copyright is claimed, and the software is hereby
 * placed in the public domain. In case this attempt to disclaim
 * copyright and place the software in the public domain is deemed
 * null and void, then the software is Copyright (c) 2013-2015 Jim Fougeron
 * and it is hereby released to the general public under the following
 * terms:
 *
 * This software may be modified, redistributed, and used for any
 * purpose, in source and binary forms, with or without modification.
 *
 * Generic 'scriptable' hash cracker for JtR.  These are the 'larger' crypt
 * items. They have been separated from dynamic_fmt.c, and placed into this
 * stand alone file.  In this code, there are a lot of lines of code, but
 * the code is very cookie cutter.
 *
 *  NOTE the code was so cookie cutter, that in summer 2015, it was simply
 *       DELETED from the version control.  Now the code (THIS FILE), is
 *       auto-generated by the ./configure script.  All hashes will use
 *       the same prototype code, so once that code is written correctly
 *       then all hashes should work FINE. Also, if there is an optimization
 *       or extension found, then simply editing the prototype code and
 *       rerunning configure will get all hashes fixed, or updated.
 *
 ****************************************************************************/

#if AC_BUILT
#include "autoconfig.h"
#endif
#ifndef DYNAMIC_DISABLED

#include "openssl_local_overrides.h"

#include "arch.h"

#if !FAST_FORMATS_OMP
#ifdef _OPENMP
#  define FORCE_THREAD_MD5_body
#endif
#undef _OPENMP
#endif

#include "misc.h"
#include "common.h"
#include "formats.h"
#include "sha.h"
#include "sha2.h"
#include "md5.h"
#include "md4.h"
#include "stdint.h"
#include "dynamic.h"
#include "johnswap.h"
#include "sse-intrinsics.h"
#include "dynamic_types.h"

/*
 * NOTE!!!!  All hash types must use a CTX structure, and the 'final' function
 * must be the same syntax as the oSSL interface.  final(uchar *output, ctx *)
 * Hashes with this order reversed, need a #define here, to 'fix' their order
 */

#include "gost.h"
#define john_gost_final(a,b) john_gost_final(b,a)

#include "sph_ripemd.h"
#define sph_ripemd128_close(a,b) sph_ripemd128_close(b,a)
#define sph_ripemd160_close(a,b) sph_ripemd160_close(b,a)
#define sph_ripemd256_close(a,b) sph_ripemd256_close(b,a)
#define sph_ripemd320_close(a,b) sph_ripemd320_close(b,a)

#include "sph_tiger.h"
#define sph_tiger_close(a,b) sph_tiger_close(b,a)

#include "sph_haval.h"
#define sph_haval128_3_close(a,b) sph_haval128_3_close(b,a)
#define sph_haval128_4_close(a,b) sph_haval128_4_close(b,a)
#define sph_haval128_5_close(a,b) sph_haval128_5_close(b,a)
#define sph_haval160_3_close(a,b) sph_haval160_3_close(b,a)
#define sph_haval160_4_close(a,b) sph_haval160_4_close(b,a)
#define sph_haval160_5_close(a,b) sph_haval160_5_close(b,a)
#define sph_haval192_3_close(a,b) sph_haval192_3_close(b,a)
#define sph_haval192_4_close(a,b) sph_haval192_4_close(b,a)
#define sph_haval192_5_close(a,b) sph_haval192_5_close(b,a)
#define sph_haval224_3_close(a,b) sph_haval224_3_close(b,a)
#define sph_haval224_4_close(a,b) sph_haval224_4_close(b,a)
#define sph_haval224_5_close(a,b) sph_haval224_5_close(b,a)
#define sph_haval256_3_close(a,b) sph_haval256_3_close(b,a)
#define sph_haval256_4_close(a,b) sph_haval256_4_close(b,a)
#define sph_haval256_5_close(a,b) sph_haval256_5_close(b,a)

#if (AC_BUILT && HAVE_WHIRLPOOL) ||	  \
   (!AC_BUILT && OPENSSL_VERSION_NUMBER >= 0x10000000 && !HAVE_NO_SSL_WHIRLPOOL)
#include <openssl/whrlpool.h>
#else
#include "sph_whirlpool.h"
#define WHIRLPOOL_CTX             sph_whirlpool_context
#define WHIRLPOOL_Init(a)         sph_whirlpool_init(a)
#define WHIRLPOOL_Update(a,b,c)   sph_whirlpool(a,b,c)
#define WHIRLPOOL_Final(a,b)      sph_whirlpool_close(b,a)
#endif

#ifdef _OPENMP
#include <omp.h>
#endif

#include "memdbg.h"

#if !defined (_DEBUG)
#define m_count m_Dynamic_Count
#endif
extern unsigned int m_count;

#define eLargeOut dyna_eLargeOut
extern eLargeOut_t *eLargeOut;

extern MD5_OUT *crypt_key_X86;
extern MD5_OUT *crypt_key2_X86;
extern MD5_IN *input_buf_X86;
extern MD5_IN *input_buf2_X86;
extern unsigned int *total_len_X86;
extern unsigned int *total_len2_X86;

extern const char *dynamic_itoa16;

#if !defined (_DEBUG)
#define curdat Dynamic_curdat
#endif
extern private_subformat_data curdat;

#if !defined (_DEBUG)
#define itoa16_w2 __Dynamic_itoa_w2
#define itoa16_w2_u __Dynamic_itoa_w2_u
#define itoa16_w2_l __Dynamic_itoa_w2_l
#endif
extern unsigned short itoa16_w2_u[256], *itoa16_w2;

static inline void eLargeOut_set(eLargeOut_t what, int tid)
{
	eLargeOut[tid] = what;
}

static inline int eLargeOut_get(int tid)
{
	return eLargeOut[tid];
}

#if !defined (_OPENMP)
#define eLargeOut_set(what, tid)  eLargeOut_set(what, 0)
#define eLargeOut_get(tid)        eLargeOut_get(0)
#endif

/* These SIMPLE setter functions, change how the large hash output format is performed   */
/* Once set, it stays that way, until set a different way.  By DEFAULT (i.e. it is reset */
/* this way each time), when crypt_all is called, the large output is in eBase16 mode    */
// These MIGHT have problems in _OPENMP builds!!
void DynamicFunc__LargeHash_OUTMode_base16(DYNA_OMP_PARAMS)
{
	eLargeOut_set(eBase16,tid);
}

void DynamicFunc__LargeHash_OUTMode_base16u(DYNA_OMP_PARAMS)
{
	eLargeOut_set(eBase16u,tid);
}

void DynamicFunc__LargeHash_OUTMode_base64(DYNA_OMP_PARAMS)
{
	eLargeOut_set(eBase64,tid);
}

void DynamicFunc__LargeHash_OUTMode_base64_nte(DYNA_OMP_PARAMS)
{
	eLargeOut_set(eBase64_nte,tid);
}

void DynamicFunc__LargeHash_OUTMode_raw(DYNA_OMP_PARAMS)
{
	eLargeOut_set(eBaseRaw,tid);
}

/******************************************************************************
 *****  These helper functions are used by all of the 'LARGE' hash functions.
 *****  These are used to convert an 'out' into the proper format, and writing
 *****  it to the buffer.  Currently we handle base-16, base-16u, base-64 and
 *****  raw buffer writing. These functions do not return any count of bytes
 *****  nor deal with things like overwrite/appending.  That has to be done in
 *****  the calling function.  The caller will get the pointers setup, then call
 *****  these helpers.  Then the caller will update any length values if needed
 *****  based upon what the output pointer was, and what was returned by these
 *****  helpers.  Doing things like this will reduce the size of the large hash
 *****  primitive functions.
 ******************************************************************************/
static inline unsigned char *hex_out_buf(unsigned char *cpi, unsigned char *cpo, int in_byte_cnt)
{
	unsigned int j;
	for (j = 0; j < in_byte_cnt; ++j) {
#if ARCH_ALLOWS_UNALIGNED
		*((unsigned short*)cpo) = itoa16_w2[*cpi++];
		cpo += 2;
#else
		*cpo++ = dynamic_itoa16[*cpi>>4];
		*cpo++ = dynamic_itoa16[*cpi&0xF];
		++cpi;
#endif
	}
	return cpo;
}

// NOTE, cpo must be at least in_byte_cnt*2 bytes of buffer
static inline unsigned char *hexu_out_buf(unsigned char *cpi, unsigned char *cpo, int in_byte_cnt)
{
	unsigned int j;
	for (j = 0; j < in_byte_cnt; ++j) {
#if ARCH_ALLOWS_UNALIGNED
		*((unsigned short*)cpo) = itoa16_w2_u[*cpi++];
		cpo += 2;
#else
		*cpo++ = itoa16u[*cpi>>4];
		*cpo++ = itoa16u[*cpi&0xF];
		++cpi;
#endif
	}
	return cpo;
}

// NOTE, cpo must be at least in_byte_cnt bytes of buffer
static inline unsigned char *raw_out_buf(unsigned char *cpi, unsigned char *cpo, int in_byte_cnt)
{
	unsigned int j;
#if ARCH_ALLOWS_UNALIGNED
	// note, all of these 'should' be even divisible by 4.  If not, then we need to rethink this logic.
	uint32_t *pi = (uint32_t*)cpi;
	uint32_t *po = (uint32_t*)cpo;
	in_byte_cnt>>=2;
	for (j = 0; j < in_byte_cnt; ++j)
		*po++ = *pi++;
	return (unsigned char*)po;
#else
	for (j = 0; j < in_byte_cnt; ++j)
		*cpo++ = *cpi++;
	return cpo;
#endif
}

// compatible 'standard' MIME base-64 encoding.
static inline unsigned char *base64_out_buf(unsigned char *cpi, unsigned char *cpo, int in_byte_cnt, int add_eq)
{
	static char *_itoa64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	while (in_byte_cnt > 2) {
		*cpo++ = _itoa64[(cpi[0] & 0xfc) >> 2];
		*cpo++ = _itoa64[((cpi[0] & 0x03) << 4) + ((cpi[1] & 0xf0) >> 4)];
		*cpo++ = _itoa64[((cpi[1] & 0x0f) << 2) + ((cpi[2] & 0xc0) >> 6)];
		*cpo++ = _itoa64[cpi[2] & 0x3f];
		cpi += 3;
		in_byte_cnt -= 3;
	}
	// easiest way is to simply have 2 'special' cases to handle these lengths
	if (in_byte_cnt==2)
	{
		*cpo++ = _itoa64[(cpi[0] & 0xfc) >> 2];
		*cpo++ = _itoa64[((cpi[0] & 0x03) << 4) + ((cpi[1] & 0xf0) >> 4)];
		*cpo++ = _itoa64[((cpi[1] & 0x0f) << 2)];
		if (add_eq) *cpo++ = '=';
	}
	if (in_byte_cnt==1)
	{
		*cpo++ = _itoa64[(cpi[0] & 0xfc) >> 2];
		*cpo++ = _itoa64[((cpi[0] & 0x03) << 4)];
		if (add_eq) { *cpo++ = '='; *cpo++ = '='; }
	}
	return cpo;
}

int large_hash_output(unsigned char *cpi, unsigned char *cpo, int in_byte_cnt, int tid)
{
	unsigned char *cpo2=cpo;
	switch(eLargeOut_get(tid)) {
		case eBase16:
			cpo2 = hex_out_buf(cpi, cpo, in_byte_cnt);
			break;
		case eBase16u:
			cpo2 = hexu_out_buf(cpi, cpo, in_byte_cnt);
			break;
		case eBase64:
			cpo2 = base64_out_buf(cpi, cpo, in_byte_cnt, 1);
			break;
		case eBase64_nte:
			cpo2 = base64_out_buf(cpi, cpo, in_byte_cnt, 0);
			break;
		case eBaseRaw:
			cpo2 = raw_out_buf(cpi, cpo, in_byte_cnt);
			break;
		case eUNK:
		default:
			exit(fprintf(stderr, "Error, unknown 'output' state found in large_hash_output function, in %s\n", curdat.dynamic_WHICH_TYPE_SIG));
	}
	return cpo2-cpo;
}

static inline uint32_t Do_FixBufferLen32(unsigned char *input_buf, int total_len, int BE_HASH)
{
	uint32_t *p;
	unsigned char *cp;
	unsigned int i;
	uint32_t ret = (total_len / 64) + 1;

	if (total_len % 64 > 55)
		++ret;
	cp = &(input_buf[total_len]);
	i = total_len;
	// first, get us to an even 32 bit boundary.
	while (i&3) {
		*cp++ = 0;
		++i;
	}
	// now switch to uint_32's
	p = (uint32_t *)cp;
	// this is how many 32 bit words max we will clean.
	i = ((ret<<6)-i)/4;
	while (i--) {
		*p++ = 0;
		if (!p[0] && !p[1])
		break;
	}
	input_buf[total_len] = 0x80;
	p = (uint32_t *)input_buf;
	if (BE_HASH) {
		p[(ret*16)-2] = 0;
		p[(ret*16)-1] = JOHNSWAP(total_len<<3);
	} else {
		p[(ret*16)-2] = (total_len<<3);
		p[(ret*16)-1] = 0;
	}
	return ret;
}

static inline uint32_t Do_FixBufferLen64(unsigned char *input_buf, int total_len, int BE_HASH)
{
	uint64_t *p;
	unsigned char *cp;
	unsigned int i;
	unsigned int ret = (total_len / 128) + 1;

	if (total_len % 128 > 111)
		++ret;
	cp = &(input_buf[total_len]);
	i = total_len;
	// first, get us to an even 64 bit boundary.
	while (i&7) {
		*cp++ = 0;
		++i;
	}
	// now switch to uint_64's
	p = (uint64_t *)cp;
	// this is how many 64 bit words max we will clean.
	i = ((ret<<7)-i)/8;
	while (i--) {
		*p++ = 0;
		if (!p[0] && !p[1])
			break;
	}
	if ( ( ((unsigned char*)p)-input_buf) < 56) {
		((uint64_t *)input_buf)[7] = 0;
	}
	if ( ( ((unsigned char*)p)-input_buf) < 56) {
		p = &(((uint64_t *)input_buf)[8]);
		i = 24; // 256 bytes - 64 bytes (for first 32 bit MD buffer) / 8 bytes per uint64_t
		while (i--) {
			*p++ = 0;
			if (!p[0] && !p[1])
				break;
		}
	}
	input_buf[total_len] = 0x80;
	p = (uint64_t *)input_buf;

	if (BE_HASH) {
		p[(ret*16)-2] = 0;
		p[(ret*16)-1] = JOHNSWAP64(total_len<<3);
	} else {
		p[(ret*16)-2] = (total_len<<3);
		p[(ret*16)-1] = 0;
	}

	return ret;
}

/*
 * NOTE, all code after this point should NEVER be hand edited.
 * if there are bugs found, then the code in dynamic_big_crypt_hash.cxx
 * is what needs to be fixed, and then the build procedure 'may' also
 * need to be updated.  Multiple CPP's of the dynamic_big_crypt_hash.cxx
 * is what generates all of the data following this comment
 */

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=MD5 PARAHASH=MD5 BIN_SZ=16 BIN_REAL_SZ=16 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=MD5_CTX HASH_Init=MD5_Init HASH_Update=MD5_Update HASH_Final=MD5_Final SSEBody=SSEmd5body SSE_LIMBS=4 SSEFLAGS=  UNDEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the MD5 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_MD5
#define MD5_LOOPS (SIMD_COEF_32*SIMD_PARA_MD5)
static const unsigned int MD5_inc = MD5_LOOPS;

static void DoMD5_crypt_f_sse(void *in, int len[MD5_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(16*MD5_LOOPS)/sizeof(ARCH_WORD_32)];
	unsigned int i, j, loops[MD5_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < MD5_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, len[i], 0);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSEmd5body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < MD5_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*(16/sizeof(ARCH_WORD_32))*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					((ARCH_WORD_32*)out)[(i*4)+j] =  a[(j*SIMD_COEF_32)+offx];
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

static void DoMD5_crypt_sse(void *in, int ilen[MD5_LOOPS], void *out[MD5_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(16*MD5_LOOPS)/sizeof(ARCH_WORD_32)];
	union yy { unsigned char u[16]; ARCH_WORD_32 a[16/sizeof(ARCH_WORD_32)]; } y;
	unsigned int i, j, loops[MD5_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < MD5_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, ilen[i], 0);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSEmd5body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < MD5_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*16/sizeof(ARCH_WORD_32)*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					y.a[j] =  a[(j*SIMD_COEF_32)+offx];
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 16, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

#else
#define MD5_LOOPS 1
static const unsigned int MD5_inc = 1;

static void inline DoMD5_crypt_f(void *in, int len, void *out)
{
	unsigned char *crypt_out=(unsigned char*)out;
	MD5_CTX ctx;
	MD5_Init(&ctx);
	MD5_Update(&ctx, in, len);
	MD5_Final(crypt_out, &ctx);
}

static void inline DoMD5_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[16];
	MD5_CTX ctx;
	MD5_Init(&ctx);
	MD5_Update(&ctx, in, ilen);
	MD5_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 16);
		*tot_len += 16*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 16, tid);
}
#endif

void DynamicFunc__MD5_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
		int len[MD5_LOOPS];
		unsigned int j;
		void *out[MD5_LOOPS];
		for (j = 0; j < MD5_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoMD5_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoMD5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__MD5_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
		int len[MD5_LOOPS];
		unsigned int j;
		void *out[MD5_LOOPS];
		for (j = 0; j < MD5_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoMD5_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoMD5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__MD5_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
		int len[MD5_LOOPS];
		unsigned int j;
		unsigned int x[MD5_LOOPS];
		void *out[MD5_LOOPS];
		for (j = 0; j < MD5_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD5_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD5_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD5_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
		int len[MD5_LOOPS];
		unsigned int j;
		unsigned int x[MD5_LOOPS];
		void *out[MD5_LOOPS];
		for (j = 0; j < MD5_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD5_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD5_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD5_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
		int len[MD5_LOOPS];
		unsigned int j;
		unsigned int x[MD5_LOOPS];
		void *out[MD5_LOOPS];
		for (j = 0; j < MD5_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD5_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD5_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD5_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
		int len[MD5_LOOPS];
		unsigned int j;
		unsigned int x[MD5_LOOPS];
		void *out[MD5_LOOPS];
		for (j = 0; j < MD5_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD5_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD5_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD5_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
	int len[MD5_LOOPS];
	unsigned int j;
	for (j = 0; j < MD5_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoMD5_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoMD5_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__MD5_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD5_inc) {
#ifdef SIMD_PARA_MD5
	int len[MD5_LOOPS];
	unsigned int j;
	for (j = 0; j < MD5_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoMD5_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoMD5_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoMD5_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=MD4 PARAHASH=MD4 BIN_SZ=16 BIN_REAL_SZ=16 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=MD4_CTX HASH_Init=MD4_Init HASH_Update=MD4_Update HASH_Final=MD4_Final SSEBody=SSEmd4body SSE_LIMBS=4 SSEFLAGS=  UNDEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the MD4 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_MD4
#define MD4_LOOPS (SIMD_COEF_32*SIMD_PARA_MD4)
static const unsigned int MD4_inc = MD4_LOOPS;

static void DoMD4_crypt_f_sse(void *in, int len[MD4_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(16*MD4_LOOPS)/sizeof(ARCH_WORD_32)];
	unsigned int i, j, loops[MD4_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < MD4_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, len[i], 0);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSEmd4body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < MD4_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*(16/sizeof(ARCH_WORD_32))*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					((ARCH_WORD_32*)out)[(i*4)+j] =  a[(j*SIMD_COEF_32)+offx];
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

static void DoMD4_crypt_sse(void *in, int ilen[MD4_LOOPS], void *out[MD4_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(16*MD4_LOOPS)/sizeof(ARCH_WORD_32)];
	union yy { unsigned char u[16]; ARCH_WORD_32 a[16/sizeof(ARCH_WORD_32)]; } y;
	unsigned int i, j, loops[MD4_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < MD4_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, ilen[i], 0);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSEmd4body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < MD4_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*16/sizeof(ARCH_WORD_32)*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					y.a[j] =  a[(j*SIMD_COEF_32)+offx];
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 16, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

#else
#define MD4_LOOPS 1
static const unsigned int MD4_inc = 1;

static void inline DoMD4_crypt_f(void *in, int len, void *out)
{
	unsigned char *crypt_out=(unsigned char*)out;
	MD4_CTX ctx;
	MD4_Init(&ctx);
	MD4_Update(&ctx, in, len);
	MD4_Final(crypt_out, &ctx);
}

static void inline DoMD4_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[16];
	MD4_CTX ctx;
	MD4_Init(&ctx);
	MD4_Update(&ctx, in, ilen);
	MD4_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 16);
		*tot_len += 16*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 16, tid);
}
#endif

void DynamicFunc__MD4_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
		int len[MD4_LOOPS];
		unsigned int j;
		void *out[MD4_LOOPS];
		for (j = 0; j < MD4_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoMD4_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoMD4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__MD4_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
		int len[MD4_LOOPS];
		unsigned int j;
		void *out[MD4_LOOPS];
		for (j = 0; j < MD4_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoMD4_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoMD4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__MD4_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
		int len[MD4_LOOPS];
		unsigned int j;
		unsigned int x[MD4_LOOPS];
		void *out[MD4_LOOPS];
		for (j = 0; j < MD4_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD4_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD4_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD4_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
		int len[MD4_LOOPS];
		unsigned int j;
		unsigned int x[MD4_LOOPS];
		void *out[MD4_LOOPS];
		for (j = 0; j < MD4_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD4_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD4_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD4_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
		int len[MD4_LOOPS];
		unsigned int j;
		unsigned int x[MD4_LOOPS];
		void *out[MD4_LOOPS];
		for (j = 0; j < MD4_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD4_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD4_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD4_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
		int len[MD4_LOOPS];
		unsigned int j;
		unsigned int x[MD4_LOOPS];
		void *out[MD4_LOOPS];
		for (j = 0; j < MD4_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoMD4_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < MD4_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoMD4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__MD4_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
	int len[MD4_LOOPS];
	unsigned int j;
	for (j = 0; j < MD4_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoMD4_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoMD4_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__MD4_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += MD4_inc) {
#ifdef SIMD_PARA_MD4
	int len[MD4_LOOPS];
	unsigned int j;
	for (j = 0; j < MD4_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoMD4_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoMD4_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoMD4_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=SHA1 PARAHASH=SHA1 BIN_SZ=20 BIN_REAL_SZ=20 BE_HASH=1 JSWAPH=JOHNSWAP( JSWAPT=); HASH_CTX=SHA_CTX HASH_Init=SHA1_Init HASH_Update=SHA1_Update HASH_Final=SHA1_Final SSEBody=SSESHA1body SSE_LIMBS=4 SSEFLAGS=  DEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the SHA1 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_SHA1
#define SHA1_LOOPS (SIMD_COEF_32*SIMD_PARA_SHA1)
static const unsigned int SHA1_inc = SHA1_LOOPS;

static void DoSHA1_crypt_f_sse(void *in, int len[SHA1_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(20*SHA1_LOOPS)/sizeof(ARCH_WORD_32)];
	unsigned int i, j, loops[SHA1_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA1_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, len[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA1body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA1_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*(20/sizeof(ARCH_WORD_32))*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					((ARCH_WORD_32*)out)[(i*4)+j] = JOHNSWAP(a[(j*SIMD_COEF_32)+offx]);
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

static void DoSHA1_crypt_sse(void *in, int ilen[SHA1_LOOPS], void *out[SHA1_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(20*SHA1_LOOPS)/sizeof(ARCH_WORD_32)];
	union yy { unsigned char u[20]; ARCH_WORD_32 a[20/sizeof(ARCH_WORD_32)]; } y;
	unsigned int i, j, loops[SHA1_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA1_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, ilen[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA1body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA1_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*20/sizeof(ARCH_WORD_32)*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				for (j = 0; j < 20/sizeof(ARCH_WORD_32); ++j) {
					y.a[j] = JOHNSWAP(a[(j*SIMD_COEF_32)+offx]);
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 20, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

#else
#define SHA1_LOOPS 1
static const unsigned int SHA1_inc = 1;

static void inline DoSHA1_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[20]; ARCH_WORD_32 a[20/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	SHA_CTX ctx;
	SHA1_Init(&ctx);
	SHA1_Update(&ctx, in, len);
	SHA1_Final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoSHA1_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[20];
	SHA_CTX ctx;
	SHA1_Init(&ctx);
	SHA1_Update(&ctx, in, ilen);
	SHA1_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 20);
		*tot_len += 20*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 20, tid);
}
#endif

void DynamicFunc__SHA1_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
		int len[SHA1_LOOPS];
		unsigned int j;
		void *out[SHA1_LOOPS];
		for (j = 0; j < SHA1_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA1_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoSHA1_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA1_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
		int len[SHA1_LOOPS];
		unsigned int j;
		void *out[SHA1_LOOPS];
		for (j = 0; j < SHA1_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA1_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoSHA1_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA1_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
		int len[SHA1_LOOPS];
		unsigned int j;
		unsigned int x[SHA1_LOOPS];
		void *out[SHA1_LOOPS];
		for (j = 0; j < SHA1_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA1_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA1_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA1_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA1_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
		int len[SHA1_LOOPS];
		unsigned int j;
		unsigned int x[SHA1_LOOPS];
		void *out[SHA1_LOOPS];
		for (j = 0; j < SHA1_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA1_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA1_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA1_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA1_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
		int len[SHA1_LOOPS];
		unsigned int j;
		unsigned int x[SHA1_LOOPS];
		void *out[SHA1_LOOPS];
		for (j = 0; j < SHA1_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA1_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA1_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA1_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA1_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
		int len[SHA1_LOOPS];
		unsigned int j;
		unsigned int x[SHA1_LOOPS];
		void *out[SHA1_LOOPS];
		for (j = 0; j < SHA1_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA1_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA1_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA1_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA1_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
	int len[SHA1_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA1_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoSHA1_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA1_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__SHA1_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA1_inc) {
#ifdef SIMD_PARA_SHA1
	int len[SHA1_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA1_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoSHA1_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA1_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA1_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=SHA224 PARAHASH=SHA256 BIN_SZ=32 BIN_REAL_SZ=28 BE_HASH=1 JSWAPH=JOHNSWAP( JSWAPT=); HASH_CTX=SHA256_CTX HASH_Init=SHA224_Init HASH_Update=SHA256_Update HASH_Final=SHA256_Final SSEBody=SSESHA256body SSE_LIMBS=4 SSEFLAGS=|SSEi_CRYPT_SHA224 DEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the SHA224 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_SHA256
#define SHA224_LOOPS (SIMD_COEF_32*SIMD_PARA_SHA256)
static const unsigned int SHA224_inc = SHA224_LOOPS;

static void DoSHA224_crypt_f_sse(void *in, int len[SHA224_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(32*SHA224_LOOPS)/sizeof(ARCH_WORD_32)];
	unsigned int i, j, loops[SHA224_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA224_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, len[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA256body(cp, a, a, SSEi_FLAT_IN|SSEi_CRYPT_SHA224|SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA224_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*(32/sizeof(ARCH_WORD_32))*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					((ARCH_WORD_32*)out)[(i*4)+j] = JOHNSWAP(a[(j*SIMD_COEF_32)+offx]);
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

static void DoSHA224_crypt_sse(void *in, int ilen[SHA224_LOOPS], void *out[SHA224_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(32*SHA224_LOOPS)/sizeof(ARCH_WORD_32)];
	union yy { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } y;
	unsigned int i, j, loops[SHA224_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA224_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, ilen[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA256body(cp, a, a, SSEi_FLAT_IN|SSEi_CRYPT_SHA224|SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA224_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*32/sizeof(ARCH_WORD_32)*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				for (j = 0; j < 32/sizeof(ARCH_WORD_32); ++j) {
					y.a[j] = JOHNSWAP(a[(j*SIMD_COEF_32)+offx]);
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 28, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

#else
#define SHA224_LOOPS 1
static const unsigned int SHA224_inc = 1;

static void inline DoSHA224_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	SHA256_CTX ctx;
	SHA224_Init(&ctx);
	SHA256_Update(&ctx, in, len);
	SHA256_Final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoSHA224_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	SHA256_CTX ctx;
	SHA224_Init(&ctx);
	SHA256_Update(&ctx, in, ilen);
	SHA256_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 28);
		*tot_len += 28*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 28, tid);
}
#endif

void DynamicFunc__SHA224_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA224_LOOPS];
		unsigned int j;
		void *out[SHA224_LOOPS];
		for (j = 0; j < SHA224_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA224_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoSHA224_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA224_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA224_LOOPS];
		unsigned int j;
		void *out[SHA224_LOOPS];
		for (j = 0; j < SHA224_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA224_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoSHA224_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA224_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA224_LOOPS];
		unsigned int j;
		unsigned int x[SHA224_LOOPS];
		void *out[SHA224_LOOPS];
		for (j = 0; j < SHA224_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA224_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA224_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA224_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA224_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA224_LOOPS];
		unsigned int j;
		unsigned int x[SHA224_LOOPS];
		void *out[SHA224_LOOPS];
		for (j = 0; j < SHA224_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA224_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA224_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA224_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA224_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA224_LOOPS];
		unsigned int j;
		unsigned int x[SHA224_LOOPS];
		void *out[SHA224_LOOPS];
		for (j = 0; j < SHA224_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA224_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA224_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA224_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA224_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA224_LOOPS];
		unsigned int j;
		unsigned int x[SHA224_LOOPS];
		void *out[SHA224_LOOPS];
		for (j = 0; j < SHA224_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA224_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA224_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA224_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA224_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
	int len[SHA224_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA224_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoSHA224_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA224_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__SHA224_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA224_inc) {
#ifdef SIMD_PARA_SHA256
	int len[SHA224_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA224_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoSHA224_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA224_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA224_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=SHA256 PARAHASH=SHA256 BIN_SZ=32 BIN_REAL_SZ=32 BE_HASH=1 JSWAPH=JOHNSWAP( JSWAPT=); HASH_CTX=SHA256_CTX HASH_Init=SHA256_Init HASH_Update=SHA256_Update HASH_Final=SHA256_Final SSEBody=SSESHA256body SSE_LIMBS=4 SSEFLAGS=  DEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the SHA256 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_SHA256
#define SHA256_LOOPS (SIMD_COEF_32*SIMD_PARA_SHA256)
static const unsigned int SHA256_inc = SHA256_LOOPS;

static void DoSHA256_crypt_f_sse(void *in, int len[SHA256_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(32*SHA256_LOOPS)/sizeof(ARCH_WORD_32)];
	unsigned int i, j, loops[SHA256_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA256_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, len[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA256body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA256_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*(32/sizeof(ARCH_WORD_32))*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_32); ++j) {
					((ARCH_WORD_32*)out)[(i*4)+j] = JOHNSWAP(a[(j*SIMD_COEF_32)+offx]);
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

static void DoSHA256_crypt_sse(void *in, int ilen[SHA256_LOOPS], void *out[SHA256_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_32 a[(32*SHA256_LOOPS)/sizeof(ARCH_WORD_32)];
	union yy { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } y;
	unsigned int i, j, loops[SHA256_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA256_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen32(cp, ilen[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA256body(cp, a, a, SSEi_FLAT_IN |SSEi_4BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA256_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_32)*32/sizeof(ARCH_WORD_32)*SIMD_COEF_32)+(i&(SIMD_COEF_32-1));
				for (j = 0; j < 32/sizeof(ARCH_WORD_32); ++j) {
					y.a[j] = JOHNSWAP(a[(j*SIMD_COEF_32)+offx]);
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 32, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 32*2;
		++cnt;
	}
}

#else
#define SHA256_LOOPS 1
static const unsigned int SHA256_inc = 1;

static void inline DoSHA256_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	SHA256_CTX ctx;
	SHA256_Init(&ctx);
	SHA256_Update(&ctx, in, len);
	SHA256_Final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoSHA256_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	SHA256_CTX ctx;
	SHA256_Init(&ctx);
	SHA256_Update(&ctx, in, ilen);
	SHA256_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 32);
		*tot_len += 32*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 32, tid);
}
#endif

void DynamicFunc__SHA256_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA256_LOOPS];
		unsigned int j;
		void *out[SHA256_LOOPS];
		for (j = 0; j < SHA256_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA256_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoSHA256_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA256_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA256_LOOPS];
		unsigned int j;
		void *out[SHA256_LOOPS];
		for (j = 0; j < SHA256_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA256_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoSHA256_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA256_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA256_LOOPS];
		unsigned int j;
		unsigned int x[SHA256_LOOPS];
		void *out[SHA256_LOOPS];
		for (j = 0; j < SHA256_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA256_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA256_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA256_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA256_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA256_LOOPS];
		unsigned int j;
		unsigned int x[SHA256_LOOPS];
		void *out[SHA256_LOOPS];
		for (j = 0; j < SHA256_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA256_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA256_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA256_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA256_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA256_LOOPS];
		unsigned int j;
		unsigned int x[SHA256_LOOPS];
		void *out[SHA256_LOOPS];
		for (j = 0; j < SHA256_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA256_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA256_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA256_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA256_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
		int len[SHA256_LOOPS];
		unsigned int j;
		unsigned int x[SHA256_LOOPS];
		void *out[SHA256_LOOPS];
		for (j = 0; j < SHA256_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA256_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA256_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA256_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA256_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
	int len[SHA256_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA256_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoSHA256_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA256_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__SHA256_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA256_inc) {
#ifdef SIMD_PARA_SHA256
	int len[SHA256_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA256_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoSHA256_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA256_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA256_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=64 HASH=SHA384 PARAHASH=SHA512 BIN_SZ=64 BIN_REAL_SZ=48 BE_HASH=1 JSWAPH=JOHNSWAP64( JSWAPT=); HASH_CTX=SHA512_CTX HASH_Init=SHA384_Init HASH_Update=SHA512_Update HASH_Final=SHA512_Final SSEBody=SSESHA512body SSE_LIMBS=2 SSEFLAGS=|SSEi_CRYPT_SHA384 DEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the SHA384 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_SHA512
#define SHA384_LOOPS (SIMD_COEF_64*SIMD_PARA_SHA512)
static const unsigned int SHA384_inc = SHA384_LOOPS;

static void DoSHA384_crypt_f_sse(void *in, int len[SHA384_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_64 a[(64*SHA384_LOOPS)/sizeof(ARCH_WORD_64)];
	unsigned int i, j, loops[SHA384_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA384_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen64(cp, len[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA512body(cp, a, a, SSEi_FLAT_IN|SSEi_CRYPT_SHA384|SSEi_2BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA384_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_64)*(64/sizeof(ARCH_WORD_64))*SIMD_COEF_64)+(i&(SIMD_COEF_64-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_64); ++j) {
					((ARCH_WORD_64*)out)[(i*2)+j] = JOHNSWAP64(a[(j*SIMD_COEF_64)+offx]);
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 64*2;
		++cnt;
	}
}

static void DoSHA384_crypt_sse(void *in, int ilen[SHA384_LOOPS], void *out[SHA384_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_64 a[(64*SHA384_LOOPS)/sizeof(ARCH_WORD_64)];
	union yy { unsigned char u[64]; ARCH_WORD_64 a[64/sizeof(ARCH_WORD_64)]; } y;
	unsigned int i, j, loops[SHA384_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA384_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen64(cp, ilen[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA512body(cp, a, a, SSEi_FLAT_IN|SSEi_CRYPT_SHA384|SSEi_2BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA384_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_64)*64/sizeof(ARCH_WORD_64)*SIMD_COEF_64)+(i&(SIMD_COEF_64-1));
				for (j = 0; j < 64/sizeof(ARCH_WORD_64); ++j) {
					y.a[j] = JOHNSWAP64(a[(j*SIMD_COEF_64)+offx]);
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 48, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 64*2;
		++cnt;
	}
}

#else
#define SHA384_LOOPS 1
static const unsigned int SHA384_inc = 1;

static void inline DoSHA384_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[64]; ARCH_WORD_64 a[64/sizeof(ARCH_WORD_64)]; } u;
	unsigned char *crypt_out=u.u;
	SHA512_CTX ctx;
	SHA384_Init(&ctx);
	SHA512_Update(&ctx, in, len);
	SHA512_Final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoSHA384_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[64];
	SHA512_CTX ctx;
	SHA384_Init(&ctx);
	SHA512_Update(&ctx, in, ilen);
	SHA512_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 48);
		*tot_len += 48*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 48, tid);
}
#endif

void DynamicFunc__SHA384_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA384_LOOPS];
		unsigned int j;
		void *out[SHA384_LOOPS];
		for (j = 0; j < SHA384_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA384_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoSHA384_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA384_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA384_LOOPS];
		unsigned int j;
		void *out[SHA384_LOOPS];
		for (j = 0; j < SHA384_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA384_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoSHA384_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA384_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA384_LOOPS];
		unsigned int j;
		unsigned int x[SHA384_LOOPS];
		void *out[SHA384_LOOPS];
		for (j = 0; j < SHA384_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA384_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA384_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA384_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA384_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA384_LOOPS];
		unsigned int j;
		unsigned int x[SHA384_LOOPS];
		void *out[SHA384_LOOPS];
		for (j = 0; j < SHA384_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA384_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA384_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA384_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA384_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA384_LOOPS];
		unsigned int j;
		unsigned int x[SHA384_LOOPS];
		void *out[SHA384_LOOPS];
		for (j = 0; j < SHA384_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA384_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA384_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA384_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA384_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA384_LOOPS];
		unsigned int j;
		unsigned int x[SHA384_LOOPS];
		void *out[SHA384_LOOPS];
		for (j = 0; j < SHA384_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA384_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA384_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA384_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA384_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
	int len[SHA384_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA384_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoSHA384_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA384_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__SHA384_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA384_inc) {
#ifdef SIMD_PARA_SHA512
	int len[SHA384_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA384_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoSHA384_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA384_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA384_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=64 HASH=SHA512 PARAHASH=SHA512 BIN_SZ=64 BIN_REAL_SZ=64 BE_HASH=1 JSWAPH=JOHNSWAP64( JSWAPT=); HASH_CTX=SHA512_CTX HASH_Init=SHA512_Init HASH_Update=SHA512_Update HASH_Final=SHA512_Final SSEBody=SSESHA512body SSE_LIMBS=2 SSEFLAGS=  DEFINED=TRUNC_TO16
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the SHA512 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#ifdef SIMD_PARA_SHA512
#define SHA512_LOOPS (SIMD_COEF_64*SIMD_PARA_SHA512)
static const unsigned int SHA512_inc = SHA512_LOOPS;

static void DoSHA512_crypt_f_sse(void *in, int len[SHA512_LOOPS], void *out)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_64 a[(64*SHA512_LOOPS)/sizeof(ARCH_WORD_64)];
	unsigned int i, j, loops[SHA512_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA512_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen64(cp, len[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA512body(cp, a, a, SSEi_FLAT_IN |SSEi_2BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA512_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_64)*(64/sizeof(ARCH_WORD_64))*SIMD_COEF_64)+(i&(SIMD_COEF_64-1));
				// only 16 bytes in the 'final'
				for (j = 0; j < 16/sizeof(ARCH_WORD_64); ++j) {
					((ARCH_WORD_64*)out)[(i*2)+j] = JOHNSWAP64(a[(j*SIMD_COEF_64)+offx]);
				}
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 64*2;
		++cnt;
	}
}

static void DoSHA512_crypt_sse(void *in, int ilen[SHA512_LOOPS], void *out[SHA512_LOOPS], unsigned int *tot_len, int tid)
{
	JTR_ALIGN(MEM_ALIGN_SIMD) ARCH_WORD_64 a[(64*SHA512_LOOPS)/sizeof(ARCH_WORD_64)];
	union yy { unsigned char u[64]; ARCH_WORD_64 a[64/sizeof(ARCH_WORD_64)]; } y;
	unsigned int i, j, loops[SHA512_LOOPS], bMore, cnt;
	unsigned char *cp = (unsigned char*)in;
	for (i = 0; i < SHA512_LOOPS; ++i) {
		loops[i] = Do_FixBufferLen64(cp, ilen[i], 1);
		cp += 64*4;
	}
	cp = (unsigned char*)in;
	bMore = 1;
	cnt = 1;
	while (bMore) {
		SSESHA512body(cp, a, a, SSEi_FLAT_IN |SSEi_2BUF_INPUT_FIRST_BLK|(cnt==1?0:SSEi_RELOAD));
		bMore = 0;
		for (i = 0; i < SHA512_LOOPS; ++i) {
			if (cnt == loops[i]) {
				unsigned int offx = ((i/SIMD_COEF_64)*64/sizeof(ARCH_WORD_64)*SIMD_COEF_64)+(i&(SIMD_COEF_64-1));
				for (j = 0; j < 64/sizeof(ARCH_WORD_64); ++j) {
					y.a[j] = JOHNSWAP64(a[(j*SIMD_COEF_64)+offx]);
				}
				*(tot_len+i) += large_hash_output(y.u, &(((unsigned char*)out[i])[*(tot_len+i)]), 64, tid);
			} else if (cnt < loops[i])
				bMore = 1;
		}
		cp += 64*2;
		++cnt;
	}
}

#else
#define SHA512_LOOPS 1
static const unsigned int SHA512_inc = 1;

static void inline DoSHA512_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[64]; ARCH_WORD_64 a[64/sizeof(ARCH_WORD_64)]; } u;
	unsigned char *crypt_out=u.u;
	SHA512_CTX ctx;
	SHA512_Init(&ctx);
	SHA512_Update(&ctx, in, len);
	SHA512_Final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoSHA512_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[64];
	SHA512_CTX ctx;
	SHA512_Init(&ctx);
	SHA512_Update(&ctx, in, ilen);
	SHA512_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 64);
		*tot_len += 64*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 64, tid);
}
#endif

void DynamicFunc__SHA512_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA512_LOOPS];
		unsigned int j;
		void *out[SHA512_LOOPS];
		for (j = 0; j < SHA512_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA512_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, &(total_len2_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoSHA512_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA512_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA512_LOOPS];
		unsigned int j;
		void *out[SHA512_LOOPS];
		for (j = 0; j < SHA512_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
		}
		DoSHA512_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, &(total_len_X86[i]), tid);
#else
		#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoSHA512_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
#endif
	}
}

void DynamicFunc__SHA512_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA512_LOOPS];
		unsigned int j;
		unsigned int x[SHA512_LOOPS];
		void *out[SHA512_LOOPS];
		for (j = 0; j < SHA512_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA512_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA512_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA512_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA512_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA512_LOOPS];
		unsigned int j;
		unsigned int x[SHA512_LOOPS];
		void *out[SHA512_LOOPS];
		for (j = 0; j < SHA512_LOOPS; ++j) {
			len[j] = total_len_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA512_crypt_sse(input_buf_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA512_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA512_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA512_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA512_LOOPS];
		unsigned int j;
		unsigned int x[SHA512_LOOPS];
		void *out[SHA512_LOOPS];
		for (j = 0; j < SHA512_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA512_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA512_LOOPS; ++j)
			total_len_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA512_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA512_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
		int len[SHA512_LOOPS];
		unsigned int j;
		unsigned int x[SHA512_LOOPS];
		void *out[SHA512_LOOPS];
		for (j = 0; j < SHA512_LOOPS; ++j) {
			len[j] = total_len2_X86[i+j];
			#if (MD5_X2)
			if (j&1)
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x2.b2;
			else
			#endif
				out[j] = input_buf2_X86[(i+j)>>MD5_X2].x1.b;
			x[j] = 0;
		}
		DoSHA512_crypt_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, out, x, tid);
		for (j = 0; j < SHA512_LOOPS; ++j)
			total_len2_X86[i+j] = x[j];
#else
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoSHA512_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
#endif
	}
}

void DynamicFunc__SHA512_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
	int len[SHA512_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA512_LOOPS; ++j)
		len[j] = total_len_X86[i+j];
	DoSHA512_crypt_f_sse(input_buf_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA512_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

void DynamicFunc__SHA512_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += SHA512_inc) {
#ifdef SIMD_PARA_SHA512
	int len[SHA512_LOOPS];
	unsigned int j;
	for (j = 0; j < SHA512_LOOPS; ++j)
		len[j] = total_len2_X86[i+j];
	DoSHA512_crypt_f_sse(input_buf2_X86[i>>MD5_X2].x1.b, len, crypt_key_X86[i>>MD5_X2].x1.b);
#else
	#if (MD5_X2)
		if (i & 1)
			DoSHA512_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoSHA512_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
#endif
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=GOST PARAHASH=GOST BIN_SZ=32 BIN_REAL_SZ=32 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=gost_ctx HASH_Init=john_gost_init HASH_Update=john_gost_update HASH_Final=john_gost_final SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_GOST
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the GOST functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define GOST_LOOPS 1
static const unsigned int GOST_inc = 1;

static void inline DoGOST_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	gost_ctx ctx;
	john_gost_init(&ctx);
	john_gost_update(&ctx, in, len);
	john_gost_final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoGOST_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	gost_ctx ctx;
	john_gost_init(&ctx);
	john_gost_update(&ctx, in, ilen);
	john_gost_final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 32);
		*tot_len += 32*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 32, tid);
}

void DynamicFunc__GOST_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoGOST_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__GOST_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoGOST_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__GOST_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoGOST_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__GOST_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoGOST_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__GOST_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoGOST_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__GOST_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoGOST_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__GOST_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoGOST_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__GOST_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += GOST_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoGOST_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoGOST_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=64 HASH=WHIRLPOOL PARAHASH=WHIRLPOOL BIN_SZ=64 BIN_REAL_SZ=64 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=WHIRLPOOL_CTX HASH_Init=WHIRLPOOL_Init HASH_Update=WHIRLPOOL_Update HASH_Final=WHIRLPOOL_Final SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_WHIRLPOOL
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the WHIRLPOOL functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define WHIRLPOOL_LOOPS 1
static const unsigned int WHIRLPOOL_inc = 1;

static void inline DoWHIRLPOOL_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[64]; ARCH_WORD_64 a[64/sizeof(ARCH_WORD_64)]; } u;
	unsigned char *crypt_out=u.u;
	WHIRLPOOL_CTX ctx;
	WHIRLPOOL_Init(&ctx);
	WHIRLPOOL_Update(&ctx, in, len);
	WHIRLPOOL_Final(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoWHIRLPOOL_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[64];
	WHIRLPOOL_CTX ctx;
	WHIRLPOOL_Init(&ctx);
	WHIRLPOOL_Update(&ctx, in, ilen);
	WHIRLPOOL_Final(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 64);
		*tot_len += 64*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 64, tid);
}

void DynamicFunc__WHIRLPOOL_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoWHIRLPOOL_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoWHIRLPOOL_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoWHIRLPOOL_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoWHIRLPOOL_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoWHIRLPOOL_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoWHIRLPOOL_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoWHIRLPOOL_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__WHIRLPOOL_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += WHIRLPOOL_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoWHIRLPOOL_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoWHIRLPOOL_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=Tiger PARAHASH=Tiger BIN_SZ=24 BIN_REAL_SZ=24 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_tiger_context HASH_Init=sph_tiger_init HASH_Update=sph_tiger HASH_Final=sph_tiger_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_Tiger
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the Tiger functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define Tiger_LOOPS 1
static const unsigned int Tiger_inc = 1;

static void inline DoTiger_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[24]; ARCH_WORD_32 a[24/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_tiger_context ctx;
	sph_tiger_init(&ctx);
	sph_tiger(&ctx, in, len);
	sph_tiger_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoTiger_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[24];
	sph_tiger_context ctx;
	sph_tiger_init(&ctx);
	sph_tiger(&ctx, in, ilen);
	sph_tiger_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 24);
		*tot_len += 24*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 24, tid);
}

void DynamicFunc__Tiger_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoTiger_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__Tiger_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoTiger_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__Tiger_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoTiger_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__Tiger_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoTiger_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__Tiger_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoTiger_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__Tiger_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoTiger_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__Tiger_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoTiger_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__Tiger_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += Tiger_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoTiger_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoTiger_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=RIPEMD128 PARAHASH=RIPEMD128 BIN_SZ=16 BIN_REAL_SZ=16 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_ripemd128_context HASH_Init=sph_ripemd128_init HASH_Update=sph_ripemd128 HASH_Final=sph_ripemd128_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  UNDEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_RIPEMD128
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the RIPEMD128 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define RIPEMD128_LOOPS 1
static const unsigned int RIPEMD128_inc = 1;

static void inline DoRIPEMD128_crypt_f(void *in, int len, void *out)
{
	unsigned char *crypt_out=(unsigned char*)out;
	sph_ripemd128_context ctx;
	sph_ripemd128_init(&ctx);
	sph_ripemd128(&ctx, in, len);
	sph_ripemd128_close(crypt_out, &ctx);
}

static void inline DoRIPEMD128_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[16];
	sph_ripemd128_context ctx;
	sph_ripemd128_init(&ctx);
	sph_ripemd128(&ctx, in, ilen);
	sph_ripemd128_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 16);
		*tot_len += 16*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 16, tid);
}

void DynamicFunc__RIPEMD128_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoRIPEMD128_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD128_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoRIPEMD128_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD128_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD128_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD128_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD128_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD128_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD128_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD128_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD128_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD128_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD128_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__RIPEMD128_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD128_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD128_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD128_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=RIPEMD160 PARAHASH=RIPEMD160 BIN_SZ=20 BIN_REAL_SZ=20 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_ripemd160_context HASH_Init=sph_ripemd160_init HASH_Update=sph_ripemd160 HASH_Final=sph_ripemd160_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_RIPEMD160
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the RIPEMD160 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define RIPEMD160_LOOPS 1
static const unsigned int RIPEMD160_inc = 1;

static void inline DoRIPEMD160_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[20]; ARCH_WORD_32 a[20/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_ripemd160_context ctx;
	sph_ripemd160_init(&ctx);
	sph_ripemd160(&ctx, in, len);
	sph_ripemd160_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoRIPEMD160_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[20];
	sph_ripemd160_context ctx;
	sph_ripemd160_init(&ctx);
	sph_ripemd160(&ctx, in, ilen);
	sph_ripemd160_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 20);
		*tot_len += 20*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 20, tid);
}

void DynamicFunc__RIPEMD160_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoRIPEMD160_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD160_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoRIPEMD160_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD160_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD160_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD160_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD160_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD160_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD160_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD160_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD160_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD160_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD160_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__RIPEMD160_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD160_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD160_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD160_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=RIPEMD256 PARAHASH=RIPEMD256 BIN_SZ=32 BIN_REAL_SZ=32 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_ripemd256_context HASH_Init=sph_ripemd256_init HASH_Update=sph_ripemd256 HASH_Final=sph_ripemd256_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_RIPEMD256
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the RIPEMD256 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define RIPEMD256_LOOPS 1
static const unsigned int RIPEMD256_inc = 1;

static void inline DoRIPEMD256_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_ripemd256_context ctx;
	sph_ripemd256_init(&ctx);
	sph_ripemd256(&ctx, in, len);
	sph_ripemd256_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoRIPEMD256_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	sph_ripemd256_context ctx;
	sph_ripemd256_init(&ctx);
	sph_ripemd256(&ctx, in, ilen);
	sph_ripemd256_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 32);
		*tot_len += 32*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 32, tid);
}

void DynamicFunc__RIPEMD256_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoRIPEMD256_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD256_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoRIPEMD256_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD256_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD256_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD256_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD256_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD256_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD256_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD256_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD256_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD256_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD256_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__RIPEMD256_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD256_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD256_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD256_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=RIPEMD320 PARAHASH=RIPEMD320 BIN_SZ=40 BIN_REAL_SZ=40 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_ripemd320_context HASH_Init=sph_ripemd320_init HASH_Update=sph_ripemd320 HASH_Final=sph_ripemd320_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_RIPEMD320
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the RIPEMD320 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define RIPEMD320_LOOPS 1
static const unsigned int RIPEMD320_inc = 1;

static void inline DoRIPEMD320_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[40]; ARCH_WORD_32 a[40/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_ripemd320_context ctx;
	sph_ripemd320_init(&ctx);
	sph_ripemd320(&ctx, in, len);
	sph_ripemd320_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoRIPEMD320_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[40];
	sph_ripemd320_context ctx;
	sph_ripemd320_init(&ctx);
	sph_ripemd320(&ctx, in, ilen);
	sph_ripemd320_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 40);
		*tot_len += 40*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 40, tid);
}

void DynamicFunc__RIPEMD320_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoRIPEMD320_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD320_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoRIPEMD320_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__RIPEMD320_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD320_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD320_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD320_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD320_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD320_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD320_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoRIPEMD320_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__RIPEMD320_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD320_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__RIPEMD320_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += RIPEMD320_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoRIPEMD320_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoRIPEMD320_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL128_3 PARAHASH=HAVAL128_3 BIN_SZ=16 BIN_REAL_SZ=16 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval128_3_context HASH_Init=sph_haval128_3_init HASH_Update=sph_haval128_3 HASH_Final=sph_haval128_3_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL128_3
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL128_3 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL128_3_LOOPS 1
static const unsigned int HAVAL128_3_inc = 1;

static void inline DoHAVAL128_3_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[16]; ARCH_WORD_32 a[16/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval128_3_context ctx;
	sph_haval128_3_init(&ctx);
	sph_haval128_3(&ctx, in, len);
	sph_haval128_3_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL128_3_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[16];
	sph_haval128_3_context ctx;
	sph_haval128_3_init(&ctx);
	sph_haval128_3(&ctx, in, ilen);
	sph_haval128_3_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 16);
		*tot_len += 16*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 16, tid);
}

void DynamicFunc__HAVAL128_3_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL128_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL128_3_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL128_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL128_3_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_3_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_3_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_3_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_3_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL128_3_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL128_3_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_3_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL128_3_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL128_4 PARAHASH=HAVAL128_4 BIN_SZ=16 BIN_REAL_SZ=16 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval128_4_context HASH_Init=sph_haval128_4_init HASH_Update=sph_haval128_4 HASH_Final=sph_haval128_4_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL128_4
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL128_4 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL128_4_LOOPS 1
static const unsigned int HAVAL128_4_inc = 1;

static void inline DoHAVAL128_4_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[16]; ARCH_WORD_32 a[16/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval128_4_context ctx;
	sph_haval128_4_init(&ctx);
	sph_haval128_4(&ctx, in, len);
	sph_haval128_4_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL128_4_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[16];
	sph_haval128_4_context ctx;
	sph_haval128_4_init(&ctx);
	sph_haval128_4(&ctx, in, ilen);
	sph_haval128_4_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 16);
		*tot_len += 16*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 16, tid);
}

void DynamicFunc__HAVAL128_4_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL128_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL128_4_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL128_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL128_4_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_4_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_4_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_4_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_4_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL128_4_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL128_4_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_4_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL128_4_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL128_5 PARAHASH=HAVAL128_5 BIN_SZ=16 BIN_REAL_SZ=16 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval128_5_context HASH_Init=sph_haval128_5_init HASH_Update=sph_haval128_5 HASH_Final=sph_haval128_5_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL128_5
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL128_5 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL128_5_LOOPS 1
static const unsigned int HAVAL128_5_inc = 1;

static void inline DoHAVAL128_5_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[16]; ARCH_WORD_32 a[16/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval128_5_context ctx;
	sph_haval128_5_init(&ctx);
	sph_haval128_5(&ctx, in, len);
	sph_haval128_5_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL128_5_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[16];
	sph_haval128_5_context ctx;
	sph_haval128_5_init(&ctx);
	sph_haval128_5(&ctx, in, ilen);
	sph_haval128_5_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 16);
		*tot_len += 16*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 16, tid);
}

void DynamicFunc__HAVAL128_5_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL128_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL128_5_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL128_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL128_5_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_5_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_5_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_5_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL128_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL128_5_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL128_5_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL128_5_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL128_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL128_5_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL128_5_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL160_3 PARAHASH=HAVAL160_3 BIN_SZ=20 BIN_REAL_SZ=20 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval160_3_context HASH_Init=sph_haval160_3_init HASH_Update=sph_haval160_3 HASH_Final=sph_haval160_3_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL160_3
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL160_3 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL160_3_LOOPS 1
static const unsigned int HAVAL160_3_inc = 1;

static void inline DoHAVAL160_3_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[20]; ARCH_WORD_32 a[20/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval160_3_context ctx;
	sph_haval160_3_init(&ctx);
	sph_haval160_3(&ctx, in, len);
	sph_haval160_3_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL160_3_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[20];
	sph_haval160_3_context ctx;
	sph_haval160_3_init(&ctx);
	sph_haval160_3(&ctx, in, ilen);
	sph_haval160_3_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 20);
		*tot_len += 20*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 20, tid);
}

void DynamicFunc__HAVAL160_3_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL160_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL160_3_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL160_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL160_3_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_3_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_3_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_3_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_3_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL160_3_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL160_3_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_3_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL160_3_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL160_4 PARAHASH=HAVAL160_4 BIN_SZ=20 BIN_REAL_SZ=20 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval160_4_context HASH_Init=sph_haval160_4_init HASH_Update=sph_haval160_4 HASH_Final=sph_haval160_4_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL160_4
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL160_4 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL160_4_LOOPS 1
static const unsigned int HAVAL160_4_inc = 1;

static void inline DoHAVAL160_4_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[20]; ARCH_WORD_32 a[20/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval160_4_context ctx;
	sph_haval160_4_init(&ctx);
	sph_haval160_4(&ctx, in, len);
	sph_haval160_4_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL160_4_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[20];
	sph_haval160_4_context ctx;
	sph_haval160_4_init(&ctx);
	sph_haval160_4(&ctx, in, ilen);
	sph_haval160_4_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 20);
		*tot_len += 20*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 20, tid);
}

void DynamicFunc__HAVAL160_4_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL160_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL160_4_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL160_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL160_4_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_4_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_4_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_4_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_4_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL160_4_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL160_4_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_4_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL160_4_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL160_5 PARAHASH=HAVAL160_5 BIN_SZ=20 BIN_REAL_SZ=20 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval160_5_context HASH_Init=sph_haval160_5_init HASH_Update=sph_haval160_5 HASH_Final=sph_haval160_5_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL160_5
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL160_5 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL160_5_LOOPS 1
static const unsigned int HAVAL160_5_inc = 1;

static void inline DoHAVAL160_5_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[20]; ARCH_WORD_32 a[20/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval160_5_context ctx;
	sph_haval160_5_init(&ctx);
	sph_haval160_5(&ctx, in, len);
	sph_haval160_5_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL160_5_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[20];
	sph_haval160_5_context ctx;
	sph_haval160_5_init(&ctx);
	sph_haval160_5(&ctx, in, ilen);
	sph_haval160_5_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 20);
		*tot_len += 20*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 20, tid);
}

void DynamicFunc__HAVAL160_5_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL160_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL160_5_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL160_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL160_5_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_5_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_5_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_5_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL160_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL160_5_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL160_5_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL160_5_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL160_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL160_5_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL160_5_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL192_3 PARAHASH=HAVAL192_3 BIN_SZ=24 BIN_REAL_SZ=24 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval192_3_context HASH_Init=sph_haval192_3_init HASH_Update=sph_haval192_3 HASH_Final=sph_haval192_3_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL192_3
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL192_3 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL192_3_LOOPS 1
static const unsigned int HAVAL192_3_inc = 1;

static void inline DoHAVAL192_3_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[24]; ARCH_WORD_32 a[24/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval192_3_context ctx;
	sph_haval192_3_init(&ctx);
	sph_haval192_3(&ctx, in, len);
	sph_haval192_3_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL192_3_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[24];
	sph_haval192_3_context ctx;
	sph_haval192_3_init(&ctx);
	sph_haval192_3(&ctx, in, ilen);
	sph_haval192_3_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 24);
		*tot_len += 24*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 24, tid);
}

void DynamicFunc__HAVAL192_3_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL192_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL192_3_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL192_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL192_3_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_3_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_3_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_3_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_3_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL192_3_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL192_3_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_3_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL192_3_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL192_4 PARAHASH=HAVAL192_4 BIN_SZ=24 BIN_REAL_SZ=24 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval192_4_context HASH_Init=sph_haval192_4_init HASH_Update=sph_haval192_4 HASH_Final=sph_haval192_4_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL192_4
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL192_4 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL192_4_LOOPS 1
static const unsigned int HAVAL192_4_inc = 1;

static void inline DoHAVAL192_4_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[24]; ARCH_WORD_32 a[24/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval192_4_context ctx;
	sph_haval192_4_init(&ctx);
	sph_haval192_4(&ctx, in, len);
	sph_haval192_4_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL192_4_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[24];
	sph_haval192_4_context ctx;
	sph_haval192_4_init(&ctx);
	sph_haval192_4(&ctx, in, ilen);
	sph_haval192_4_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 24);
		*tot_len += 24*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 24, tid);
}

void DynamicFunc__HAVAL192_4_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL192_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL192_4_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL192_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL192_4_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_4_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_4_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_4_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_4_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL192_4_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL192_4_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_4_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL192_4_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL192_5 PARAHASH=HAVAL192_5 BIN_SZ=24 BIN_REAL_SZ=24 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval192_5_context HASH_Init=sph_haval192_5_init HASH_Update=sph_haval192_5 HASH_Final=sph_haval192_5_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL192_5
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL192_5 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL192_5_LOOPS 1
static const unsigned int HAVAL192_5_inc = 1;

static void inline DoHAVAL192_5_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[24]; ARCH_WORD_32 a[24/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval192_5_context ctx;
	sph_haval192_5_init(&ctx);
	sph_haval192_5(&ctx, in, len);
	sph_haval192_5_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL192_5_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[24];
	sph_haval192_5_context ctx;
	sph_haval192_5_init(&ctx);
	sph_haval192_5(&ctx, in, ilen);
	sph_haval192_5_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 24);
		*tot_len += 24*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 24, tid);
}

void DynamicFunc__HAVAL192_5_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL192_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL192_5_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL192_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL192_5_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_5_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_5_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_5_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL192_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL192_5_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL192_5_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL192_5_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL192_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL192_5_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL192_5_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL224_3 PARAHASH=HAVAL224_3 BIN_SZ=28 BIN_REAL_SZ=28 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval224_3_context HASH_Init=sph_haval224_3_init HASH_Update=sph_haval224_3 HASH_Final=sph_haval224_3_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL224_3
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL224_3 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL224_3_LOOPS 1
static const unsigned int HAVAL224_3_inc = 1;

static void inline DoHAVAL224_3_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[28]; ARCH_WORD_32 a[28/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval224_3_context ctx;
	sph_haval224_3_init(&ctx);
	sph_haval224_3(&ctx, in, len);
	sph_haval224_3_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL224_3_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[28];
	sph_haval224_3_context ctx;
	sph_haval224_3_init(&ctx);
	sph_haval224_3(&ctx, in, ilen);
	sph_haval224_3_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 28);
		*tot_len += 28*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 28, tid);
}

void DynamicFunc__HAVAL224_3_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL224_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL224_3_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL224_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL224_3_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_3_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_3_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_3_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_3_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL224_3_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL224_3_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_3_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL224_3_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL224_4 PARAHASH=HAVAL224_4 BIN_SZ=28 BIN_REAL_SZ=28 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval224_4_context HASH_Init=sph_haval224_4_init HASH_Update=sph_haval224_4 HASH_Final=sph_haval224_4_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL224_4
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL224_4 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL224_4_LOOPS 1
static const unsigned int HAVAL224_4_inc = 1;

static void inline DoHAVAL224_4_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[28]; ARCH_WORD_32 a[28/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval224_4_context ctx;
	sph_haval224_4_init(&ctx);
	sph_haval224_4(&ctx, in, len);
	sph_haval224_4_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL224_4_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[28];
	sph_haval224_4_context ctx;
	sph_haval224_4_init(&ctx);
	sph_haval224_4(&ctx, in, ilen);
	sph_haval224_4_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 28);
		*tot_len += 28*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 28, tid);
}

void DynamicFunc__HAVAL224_4_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL224_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL224_4_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL224_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL224_4_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_4_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_4_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_4_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_4_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL224_4_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL224_4_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_4_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL224_4_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL224_5 PARAHASH=HAVAL224_5 BIN_SZ=28 BIN_REAL_SZ=28 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval224_5_context HASH_Init=sph_haval224_5_init HASH_Update=sph_haval224_5 HASH_Final=sph_haval224_5_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL224_5
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL224_5 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL224_5_LOOPS 1
static const unsigned int HAVAL224_5_inc = 1;

static void inline DoHAVAL224_5_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[28]; ARCH_WORD_32 a[28/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval224_5_context ctx;
	sph_haval224_5_init(&ctx);
	sph_haval224_5(&ctx, in, len);
	sph_haval224_5_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL224_5_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[28];
	sph_haval224_5_context ctx;
	sph_haval224_5_init(&ctx);
	sph_haval224_5(&ctx, in, ilen);
	sph_haval224_5_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 28);
		*tot_len += 28*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 28, tid);
}

void DynamicFunc__HAVAL224_5_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL224_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL224_5_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL224_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL224_5_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_5_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_5_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_5_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL224_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL224_5_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL224_5_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL224_5_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL224_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL224_5_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL224_5_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL256_3 PARAHASH=HAVAL256_3 BIN_SZ=32 BIN_REAL_SZ=32 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval256_3_context HASH_Init=sph_haval256_3_init HASH_Update=sph_haval256_3 HASH_Final=sph_haval256_3_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL256_3
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL256_3 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL256_3_LOOPS 1
static const unsigned int HAVAL256_3_inc = 1;

static void inline DoHAVAL256_3_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval256_3_context ctx;
	sph_haval256_3_init(&ctx);
	sph_haval256_3(&ctx, in, len);
	sph_haval256_3_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL256_3_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	sph_haval256_3_context ctx;
	sph_haval256_3_init(&ctx);
	sph_haval256_3(&ctx, in, ilen);
	sph_haval256_3_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 32);
		*tot_len += 32*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 32, tid);
}

void DynamicFunc__HAVAL256_3_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL256_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL256_3_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL256_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL256_3_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_3_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_3_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_3_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_3_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_3_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_3_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL256_3_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL256_3_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_3_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_3_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL256_3_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL256_4 PARAHASH=HAVAL256_4 BIN_SZ=32 BIN_REAL_SZ=32 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval256_4_context HASH_Init=sph_haval256_4_init HASH_Update=sph_haval256_4 HASH_Final=sph_haval256_4_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL256_4
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL256_4 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL256_4_LOOPS 1
static const unsigned int HAVAL256_4_inc = 1;

static void inline DoHAVAL256_4_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval256_4_context ctx;
	sph_haval256_4_init(&ctx);
	sph_haval256_4(&ctx, in, len);
	sph_haval256_4_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL256_4_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	sph_haval256_4_context ctx;
	sph_haval256_4_init(&ctx);
	sph_haval256_4(&ctx, in, ilen);
	sph_haval256_4_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 32);
		*tot_len += 32*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 32, tid);
}

void DynamicFunc__HAVAL256_4_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL256_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL256_4_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL256_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL256_4_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_4_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_4_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_4_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_4_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_4_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_4_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL256_4_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL256_4_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_4_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_4_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL256_4_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

/***********************************************************************
 * This section of the file auto-generated by dynamic_big_crypt_hash.cin
 * being run through dynamic_big_crypt_chopper.pl with this command line
 * ./dynamic_big_crypt_chopper.pl BITS=32 HASH=HAVAL256_5 PARAHASH=HAVAL256_5 BIN_SZ=32 BIN_REAL_SZ=32 BE_HASH=0 JSWAPH=  JSWAPT=; HASH_CTX=sph_haval256_5_context HASH_Init=sph_haval256_5_init HASH_Update=sph_haval256_5 HASH_Final=sph_haval256_5_close SSEBody=  SSE_LIMBS=0 SSEFLAGS=  DEFINED=TRUNC_TO16 UNDEFINED=SIMD_PARA_HAVAL256_5
 ***********************************************************************/


/*****************************************************************************
 ****  Here are the HAVAL256_5 functions (Now using common interface). This code
 ****  This code generated from dynamic_big_crypt_hash.cin  DO NOT edit the
 ****  code in this generated file!!! It will be regenerated by ./configure
 ****  Any issues that are found MUST be fixed properly in the
 ****  dynamic_big_crypt_hash.cin file and not here in this file.
 ****************************************************************************/
#define HAVAL256_5_LOOPS 1
static const unsigned int HAVAL256_5_inc = 1;

static void inline DoHAVAL256_5_crypt_f(void *in, int len, void *out)
{
	union xx { unsigned char u[32]; ARCH_WORD_32 a[32/sizeof(ARCH_WORD_32)]; } u;
	unsigned char *crypt_out=u.u;
	sph_haval256_5_context ctx;
	sph_haval256_5_init(&ctx);
	sph_haval256_5(&ctx, in, len);
	sph_haval256_5_close(crypt_out, &ctx);
	memcpy(out, crypt_out, 16);
}

static void inline DoHAVAL256_5_crypt(void *in, int ilen, void *out, unsigned int *tot_len, int tid)
{
	unsigned char crypt_out[32];
	sph_haval256_5_context ctx;
	sph_haval256_5_init(&ctx);
	sph_haval256_5(&ctx, in, ilen);
	sph_haval256_5_close(crypt_out, &ctx);
	if (eLargeOut[0] == eBase16) {
		// since this is the usual, we avoid the extra overhead of large_hash_output, and go directly to the hex_out.
		hex_out_buf(crypt_out, &(((unsigned char*)out)[*tot_len]), 32);
		*tot_len += 32*2;
	} else
		*tot_len += large_hash_output(crypt_out, &(((unsigned char*)out)[*tot_len]), 32, tid);
}

void DynamicFunc__HAVAL256_5_crypt_input1_append_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &(total_len2_X86[i]), tid);
		else
		#endif
		DoHAVAL256_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &(total_len2_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL256_5_crypt_input2_append_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &(total_len_X86[i]), tid);
		else
		#endif
		DoHAVAL256_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &(total_len_X86[i]), tid);
	}
}

void DynamicFunc__HAVAL256_5_crypt_input1_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_5_crypt_input1_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_5_crypt(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_5_crypt_input2_overwrite_input1(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_5_crypt_input2_overwrite_input2(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	unsigned int tid=0;
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
		unsigned int x = 0;
		#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x2.b2, &x, tid);
		else
		#endif
		DoHAVAL256_5_crypt(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], input_buf2_X86[i>>MD5_X2].x1.b, &x, tid);
		total_len2_X86[i] = x;
	}
}

void DynamicFunc__HAVAL256_5_crypt_input1_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt_f(input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL256_5_crypt_f(input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

void DynamicFunc__HAVAL256_5_crypt_input2_to_output1_FINAL(DYNA_OMP_PARAMS)
{
	unsigned int i, til;

#ifdef _OPENMP
	i = first;
	til = last;
#else
	i = 0;
	til = m_count;
#endif
	for (; i < til; i += HAVAL256_5_inc) {
	#if (MD5_X2)
		if (i & 1)
			DoHAVAL256_5_crypt_f(input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x2.b2);
		else
	#endif
		DoHAVAL256_5_crypt_f(input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i], crypt_key_X86[i>>MD5_X2].x1.b);
	}
}

#endif // DYNAMIC_DISABLED
